(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global['@xmpp-plugins/roster'] = factory());
}(this, function () { 'use strict';

  var TimeoutError_1 = class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = 'TimeoutError';
    }

  };

  var delay = function delay(ms) {
    let timeout;
    const promise = new Promise(resolve => {
      timeout = setTimeout(resolve, ms);
    });
    promise.timeout = timeout;
    return promise;
  };

  var timeout = function timeout(promise, ms) {
    const promiseDelay = delay(ms);

    function cancelDelay() {
      clearTimeout(promiseDelay.timeout);
    }

    return Promise.race([promise.finally(cancelDelay), promiseDelay.then(() => {
      throw new TimeoutError_1();
    })]);
  };

  var promise = function promise(EE, event, rejectEvent = 'error', timeout) {
    return new Promise((resolve, reject) => {
      let timeoutId;

      const cleanup = () => {
        clearTimeout(timeoutId);
        EE.removeListener(event, onEvent);
        EE.removeListener(rejectEvent, onError);
      };

      function onError(reason) {
        reject(reason);
        cleanup();
      }

      function onEvent(value) {
        resolve(value);
        cleanup();
      }

      EE.once(event, onEvent);

      if (rejectEvent) {
        EE.once(rejectEvent, onError);
      }

      if (timeout) {
        timeoutId = setTimeout(() => {
          cleanup();
          reject(new TimeoutError_1());
        }, timeout);
      }
    });
  };

  var domain; // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).

  function EventHandlers() {}

  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  // require('events') === require('events').EventEmitter

  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.

  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function () {
    this.domain = null;

    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active && !(this instanceof domain.Domain)) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  }; // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  }; // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.


  function emitNone(handler, isFn, self) {
    if (isFn) handler.call(self);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self);
    }
  }

  function emitOne(handler, isFn, self, arg1) {
    if (isFn) handler.call(self, arg1);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
    }
  }

  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn) handler.call(self, arg1, arg2);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
    }
  }

  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn) handler.call(self, arg1, arg2, arg3);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn) handler.apply(self, args);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = type === 'error';
    events = this._events;
    if (events) doError = doError && events.error == null;else if (!doError) return false;
    domain = this.domain; // If there is no 'error' event listener then throw.

    if (doError) {
      er = arguments[1];

      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }

      return false;
    }

    handler = events[type];
    if (!handler) return false;
    var isFn = typeof handler === 'function';
    len = arguments.length;

    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;

      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;

      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;

      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower

      default:
        args = new Array(len - 1);

        for (i = 1; i < len; i++) args[i - 1] = arguments[i];

        emitMany(handler, isFn, this, args);
    }
    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = target._events;

    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object

        events = target._events;
      }

      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      } // Check for listener leak


      if (!existing.warned) {
        m = $getMaxListeners(target);

        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }

  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function _onceWrap(target, type, listener) {
    var fired = false;

    function g() {
      target.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }

    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }; // emits a 'removeListener' event iff the listener was removed


  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events) return this;
    list = events[type];
    if (!list) return this;

    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list[0] = undefined;

        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events;
    events = this._events;
    if (!events) return this; // not listening for removeListener, no need to emit

    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
      }

      return this;
    } // emit removeListener for all listeners on all events


    if (arguments.length === 0) {
      var keys = Object.keys(events);

      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }

      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events) ret = [];else {
      evlistener = events[type];
      if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
    }
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;

  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }; // About 1.5x faster than the two-arg version of Array#splice().


  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];

    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);

    while (i--) copy[i] = arr[i];

    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);

    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }

    return ret;
  }

  var Deferred = function Deferred() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  };

  var EventEmitter_1 = EventEmitter;
  var timeout_1 = timeout;
  var delay_1 = delay;
  var TimeoutError_1$1 = TimeoutError_1;
  var promise_1 = promise;
  var Deferred_1 = Deferred;
  var events = {
    EventEmitter: EventEmitter_1,
    timeout: timeout_1,
    delay: delay_1,
    TimeoutError: TimeoutError_1$1,
    promise: promise_1,
    Deferred: Deferred_1
  };

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var escapeXMLTable = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;'
  };

  function escapeXMLReplace(match) {
    return escapeXMLTable[match];
  }

  var unescapeXMLTable = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': "'"
  };

  function unescapeXMLReplace(match) {
    if (match[1] === '#') {
      var num;

      if (match[2] === 'x') {
        num = parseInt(match.slice(3), 16);
      } else {
        num = parseInt(match.slice(2), 10);
      } // https://www.w3.org/TR/xml/#NT-Char defines legal XML characters:
      // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]


      if (num === 0x9 || num === 0xA || num === 0xD || num >= 0x20 && num <= 0xD7FF || num >= 0xE000 && num <= 0xFFFD || num >= 0x10000 && num <= 0x10FFFF) {
        return String.fromCodePoint(num);
      }

      throw new Error('Illegal XML character 0x' + num.toString(16));
    }

    if (unescapeXMLTable[match]) {
      return unescapeXMLTable[match] || match;
    }

    throw new Error('Illegal XML entity ' + match);
  }

  var escapeXML = function escapeXML(s) {
    return s.replace(/&|<|>|"|'/g, escapeXMLReplace);
  };

  var unescapeXML = function unescapeXML(s) {
    var result = '';
    var start = -1;
    var end = -1;
    var previous = 0;

    while ((start = s.indexOf('&', previous)) !== -1 && (end = s.indexOf(';', start + 1)) !== -1) {
      result = result + s.substring(previous, start) + unescapeXMLReplace(s.substring(start, end + 1));
      previous = end + 1;
    } // shortcut if loop never entered:
    // return the original string without creating new objects


    if (previous === 0) return s; // push the remaining characters

    result = result + s.substring(previous);
    return result;
  };

  var escapeXMLText = function escapeXMLText(s) {
    return s.replace(/&|<|>/g, escapeXMLReplace);
  };

  var unescapeXMLText = function unescapeXMLText(s) {
    return s.replace(/&(amp|#38|lt|#60|gt|#62);/g, unescapeXMLReplace);
  };

  var _escape = {
    escapeXML: escapeXML,
    unescapeXML: unescapeXML,
    escapeXMLText: escapeXMLText,
    unescapeXMLText: unescapeXMLText
  };

  function nameEqual(a, b) {
    return a.name === b.name;
  }

  function attrsEqual(a, b) {
    var attrs = a.attrs;
    var keys = Object.keys(attrs);
    var length = keys.length;
    if (length !== Object.keys(b.attrs).length) return false;

    for (var i = 0, l = length; i < l; i++) {
      var key = keys[i];
      var value = attrs[key];

      if (value == null || b.attrs[key] == null) {
        // === null || undefined
        if (value !== b.attrs[key]) return false;
      } else if (value.toString() !== b.attrs[key].toString()) {
        return false;
      }
    }

    return true;
  }

  function childrenEqual(a, b) {
    var children = a.children;
    var length = children.length;
    if (length !== b.children.length) return false;

    for (var i = 0, l = length; i < l; i++) {
      var child = children[i];

      if (typeof child === 'string') {
        if (child !== b.children[i]) return false;
      } else {
        if (!child.equals(b.children[i])) return false;
      }
    }

    return true;
  }

  function equal(a, b) {
    if (!nameEqual(a, b)) return false;
    if (!attrsEqual(a, b)) return false;
    if (!childrenEqual(a, b)) return false;
    return true;
  }

  var name = nameEqual;
  var attrs = attrsEqual;
  var children = childrenEqual;
  var equal_2 = equal;
  var equal_1 = {
    name: name,
    attrs: attrs,
    children: children,
    equal: equal_2
  };

  var clone = function clone(el) {
    var clone = new el.constructor(el.name, el.attrs);

    for (var i = 0; i < el.children.length; i++) {
      var child = el.children[i];
      clone.cnode(child.clone ? child.clone() : child);
    }

    return clone;
  };

  var escapeXML$1 = _escape.escapeXML;
  var escapeXMLText$1 = _escape.escapeXMLText;
  var equal$1 = equal_1.equal;
  var nameEqual$1 = equal_1.name;
  var attrsEqual$1 = equal_1.attrs;
  var childrenEqual$1 = equal_1.children;
  /**
   * Element
   *
   * Attributes are in the element.attrs object. Children is a list of
   * either other Elements or Strings for text content.
   **/

  function Element(name, attrs) {
    this.name = name;
    this.parent = null;
    this.children = [];
    this.attrs = {};
    this.setAttrs(attrs);
  }
  /* Accessors */

  /**
   * if (element.is('message', 'jabber:client')) ...
   **/


  Element.prototype.is = function (name, xmlns) {
    return this.getName() === name && (!xmlns || this.getNS() === xmlns);
  };
  /* without prefix */


  Element.prototype.getName = function () {
    if (this.name.indexOf(':') >= 0) {
      return this.name.substr(this.name.indexOf(':') + 1);
    } else {
      return this.name;
    }
  };
  /**
   * retrieves the namespace of the current element, upwards recursively
   **/


  Element.prototype.getNS = function () {
    if (this.name.indexOf(':') >= 0) {
      var prefix = this.name.substr(0, this.name.indexOf(':'));
      return this.findNS(prefix);
    }

    return this.findNS();
  };
  /**
   * find the namespace to the given prefix, upwards recursively
   **/


  Element.prototype.findNS = function (prefix) {
    if (!prefix) {
      /* default namespace */
      if (this.attrs.xmlns) {
        return this.attrs.xmlns;
      } else if (this.parent) {
        return this.parent.findNS();
      }
    } else {
      /* prefixed namespace */
      var attr = 'xmlns:' + prefix;

      if (this.attrs[attr]) {
        return this.attrs[attr];
      } else if (this.parent) {
        return this.parent.findNS(prefix);
      }
    }
  };
  /**
   * Recursiverly gets all xmlns defined, in the form of {url:prefix}
   **/


  Element.prototype.getXmlns = function () {
    var namespaces = {};

    if (this.parent) {
      namespaces = this.parent.getXmlns();
    }

    for (var attr in this.attrs) {
      var m = attr.match('xmlns:?(.*)');

      if (this.attrs.hasOwnProperty(attr) && m) {
        namespaces[this.attrs[attr]] = m[1];
      }
    }

    return namespaces;
  };

  Element.prototype.setAttrs = function (attrs) {
    if (typeof attrs === 'string') {
      this.attrs.xmlns = attrs;
    } else if (attrs) {
      Object.keys(attrs).forEach(function (key) {
        this.attrs[key] = attrs[key];
      }, this);
    }
  };
  /**
   * xmlns can be null, returns the matching attribute.
   **/


  Element.prototype.getAttr = function (name, xmlns) {
    if (!xmlns) {
      return this.attrs[name];
    }

    var namespaces = this.getXmlns();

    if (!namespaces[xmlns]) {
      return null;
    }

    return this.attrs[[namespaces[xmlns], name].join(':')];
  };
  /**
   * xmlns can be null
   **/


  Element.prototype.getChild = function (name, xmlns) {
    return this.getChildren(name, xmlns)[0];
  };
  /**
   * xmlns can be null
   **/


  Element.prototype.getChildren = function (name, xmlns) {
    var result = [];

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];

      if (child.getName && child.getName() === name && (!xmlns || child.getNS() === xmlns)) {
        result.push(child);
      }
    }

    return result;
  };
  /**
   * xmlns and recursive can be null
   **/


  Element.prototype.getChildByAttr = function (attr, val, xmlns, recursive) {
    return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];
  };
  /**
   * xmlns and recursive can be null
   **/


  Element.prototype.getChildrenByAttr = function (attr, val, xmlns, recursive) {
    var result = [];

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];

      if (child.attrs && child.attrs[attr] === val && (!xmlns || child.getNS() === xmlns)) {
        result.push(child);
      }

      if (recursive && child.getChildrenByAttr) {
        result.push(child.getChildrenByAttr(attr, val, xmlns, true));
      }
    }

    if (recursive) {
      result = [].concat.apply([], result);
    }

    return result;
  };

  Element.prototype.getChildrenByFilter = function (filter, recursive) {
    var result = [];

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];

      if (filter(child)) {
        result.push(child);
      }

      if (recursive && child.getChildrenByFilter) {
        result.push(child.getChildrenByFilter(filter, true));
      }
    }

    if (recursive) {
      result = [].concat.apply([], result);
    }

    return result;
  };

  Element.prototype.getText = function () {
    var text = '';

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];

      if (typeof child === 'string' || typeof child === 'number') {
        text += child;
      }
    }

    return text;
  };

  Element.prototype.getChildText = function (name, xmlns) {
    var child = this.getChild(name, xmlns);
    return child ? child.getText() : null;
  };
  /**
   * Return all direct descendents that are Elements.
   * This differs from `getChildren` in that it will exclude text nodes,
   * processing instructions, etc.
   */


  Element.prototype.getChildElements = function () {
    return this.getChildrenByFilter(function (child) {
      return child instanceof Element;
    });
  };
  /* Builder */

  /** returns uppermost parent */


  Element.prototype.root = function () {
    if (this.parent) {
      return this.parent.root();
    }

    return this;
  };

  Element.prototype.tree = Element.prototype.root;
  /** just parent or itself */

  Element.prototype.up = function () {
    if (this.parent) {
      return this.parent;
    }

    return this;
  };
  /** create child node and return it */


  Element.prototype.c = function (name, attrs) {
    return this.cnode(new Element(name, attrs));
  };

  Element.prototype.cnode = function (child) {
    this.children.push(child);

    if (typeof child === 'object') {
      child.parent = this;
    }

    return child;
  };
  /** add text node and return element */


  Element.prototype.t = function (text) {
    this.children.push(text);
    return this;
  };
  /* Manipulation */

  /**
   * Either:
   *   el.remove(childEl)
   *   el.remove('author', 'urn:...')
   */


  Element.prototype.remove = function (el, xmlns) {
    var filter;

    if (typeof el === 'string') {
      /* 1st parameter is tag name */
      filter = function (child) {
        return !(child.is && child.is(el, xmlns));
      };
    } else {
      /* 1st parameter is element */
      filter = function (child) {
        return child !== el;
      };
    }

    this.children = this.children.filter(filter);
    return this;
  };

  Element.prototype.clone = function () {
    return clone(this);
  };

  Element.prototype.text = function (val) {
    if (val && this.children.length === 1) {
      this.children[0] = val;
      return this;
    }

    return this.getText();
  };

  Element.prototype.attr = function (attr, val) {
    if (typeof val !== 'undefined' || val === null) {
      if (!this.attrs) {
        this.attrs = {};
      }

      this.attrs[attr] = val;
      return this;
    }

    return this.attrs[attr];
  };
  /* Serialization */


  Element.prototype.toString = function () {
    var s = '';
    this.write(function (c) {
      s += c;
    });
    return s;
  };

  Element.prototype.toJSON = function () {
    return {
      name: this.name,
      attrs: this.attrs,
      children: this.children.map(function (child) {
        return child && child.toJSON ? child.toJSON() : child;
      })
    };
  };

  Element.prototype._addChildren = function (writer) {
    writer('>');

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      /* Skip null/undefined */

      if (child || child === 0) {
        if (child.write) {
          child.write(writer);
        } else if (typeof child === 'string') {
          writer(escapeXMLText$1(child));
        } else if (child.toString) {
          writer(escapeXMLText$1(child.toString(10)));
        }
      }
    }

    writer('</');
    writer(this.name);
    writer('>');
  };

  Element.prototype.write = function (writer) {
    writer('<');
    writer(this.name);

    for (var k in this.attrs) {
      var v = this.attrs[k];

      if (v != null) {
        // === null || undefined
        writer(' ');
        writer(k);
        writer('="');

        if (typeof v !== 'string') {
          v = v.toString();
        }

        writer(escapeXML$1(v));
        writer('"');
      }
    }

    if (this.children.length === 0) {
      writer('/>');
    } else {
      this._addChildren(writer);
    }
  };

  Element.prototype.nameEquals = function (el) {
    return nameEqual$1(this, el);
  };

  Element.prototype.attrsEquals = function (el) {
    return attrsEqual$1(this, el);
  };

  Element.prototype.childrenEquals = function (el) {
    return childrenEqual$1(this, el);
  };

  Element.prototype.equals = function (el) {
    return equal$1(this, el);
  };

  var Element_1 = Element;

  class Element$1 extends Element_1 {
    setAttrs(attrs) {
      if (typeof attrs === 'string') {
        this.attrs.xmlns = attrs;
      } else if (attrs) {
        Object.keys(attrs).forEach(function (key) {
          const val = attrs[key];
          if (val !== undefined && val !== null) this.attrs[key.toString()] = val.toString();
        }, this);
      }
    }

    append(nodes) {
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes.forEach(node => {
        this.children.push(node);

        if (typeof node === 'object') {
          node.parent = this;
        }
      });
      return this;
    }

    prepend(nodes) {
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes.forEach(node => {
        this.children.unshift(node);

        if (typeof node === 'object') {
          node.parent = this;
        }
      });
      return this;
    }

  }

  var Element_1$1 = Element$1;

  function append(el, child) {
    if (child instanceof Element_1$1) {
      el.append(child);
    } else if (Array.isArray(child)) {
      child.forEach(c => append(el, c));
    } else if (child !== null && child !== undefined) {
      el.append(String(child));
    }
  }

  function x(name, attrs, ...children) {
    const el = new Element_1$1(name, attrs); // eslint-disable-next-line unicorn/no-for-loop

    for (let i = 0; i < children.length; i++) {
      append(el, children[i]);
    }

    return el;
  }

  var x_1 = x;

  // shim for using process in browser

  if (typeof global.setTimeout === 'function') ;

  if (typeof global.clearTimeout === 'function') ;

  var performance = global.performance || {};

  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
    return new Date().getTime();
  }; // generate timestamp or delta

  var inherits;

  if (typeof Object.create === 'function') {
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }

  var inherits$1 = inherits;

  // Copyright Joyent, Inc. and other Node contributors.
  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }

    return str;
  }
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.

  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global.process)) {
      return function () {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  }
  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron)) debugEnviron =  '';
    set = set.toUpperCase();

    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;

        debugs[set] = function () {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function () {};
      }
    }

    return debugs[set];
  }
  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */

  /* legacy: obj, showHidden, depth, colors*/

  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    }; // legacy...

    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];

    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    } // set default options


    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  } // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

  inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  }; // Don't use 'blue' not visible on cmd.exe

  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };

  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }

  function stylizeNoColor(str, styleType) {
    return str;
  }

  function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
      hash[val] = true;
    });
    return hash;
  }

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // Look up the keys of the object.


    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    } // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    } // Some type of object without properties can be shortcutted.


    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        braces = ['{', '}']; // Make Array say that they are Array

    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }

    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

    if (isNull(value)) return ctx.stylize('null', 'null');
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key]
    };

    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  } // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.


  function isArray(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isString(arg) {
    return typeof arg === 'string';
  }
  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }
  function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
  }
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
    typeof arg === 'undefined';
  }
  function isBuffer(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }

  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  } // log is just a thin wrapper to console.log that prepends a timestamp


  function log() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  }

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var require$$0 = {
    inherits: inherits$1,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer,
    isPrimitive: isPrimitive,
    isFunction: isFunction,
    isError: isError,
    isDate: isDate,
    isObject: isObject,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString,
    isNumber: isNumber,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog
  };

  var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;

          var TempCtor = function () {};

          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });

  var inherits$2 = createCommonjsModule(function (module) {
    try {
      var util = require$$0;
      /* istanbul ignore next */

      if (typeof util.inherits !== 'function') throw '';
      module.exports = util.inherits;
    } catch (e) {
      /* istanbul ignore next */
      module.exports = inherits_browser;
    }
  });

  var ltx = createCommonjsModule(function (module) {

    var EventEmitter$1 = EventEmitter.EventEmitter;
    var unescapeXML = _escape.unescapeXML;
    var STATE_TEXT = 0;
    var STATE_IGNORE_COMMENT = 1;
    var STATE_IGNORE_INSTRUCTION = 2;
    var STATE_TAG_NAME = 3;
    var STATE_TAG = 4;
    var STATE_ATTR_NAME = 5;
    var STATE_ATTR_EQ = 6;
    var STATE_ATTR_QUOT = 7;
    var STATE_ATTR_VALUE = 8;
    var STATE_CDATA = 9;

    var SaxLtx = module.exports = function SaxLtx() {
      EventEmitter$1.call(this);
      var state = STATE_TEXT;
      var remainder;
      var tagName;
      var attrs;
      var endTag;
      var selfClosing;
      var attrQuote;
      var attrQuoteChar;
      var recordStart = 0;
      var attrName;

      this._handleTagOpening = function (endTag, tagName, attrs) {
        if (!endTag) {
          this.emit('startElement', tagName, attrs);

          if (selfClosing) {
            this.emit('endElement', tagName);
          }
        } else {
          this.emit('endElement', tagName);
        }
      };

      this.write = function (data) {
        if (typeof data !== 'string') {
          data = data.toString();
        }

        var pos = 0;
        /* Anything from previous write()? */

        if (remainder) {
          data = remainder + data;
          pos += remainder.length;
          remainder = null;
        }

        function endRecording() {
          if (typeof recordStart === 'number') {
            var recorded = data.substring(recordStart, pos);
            recordStart = undefined;
            return recorded;
          }
        }

        for (; pos < data.length; pos++) {
          if (state === STATE_TEXT) {
            // if we're looping through text, fast-forward using indexOf to
            // the next '<' character
            var lt = data.indexOf('<', pos);

            if (lt !== -1 && pos !== lt) {
              pos = lt;
            }
          } else if (state === STATE_ATTR_VALUE) {
            // if we're looping through an attribute, fast-forward using
            // indexOf to the next end quote character
            var quot = data.indexOf(attrQuoteChar, pos);

            if (quot !== -1) {
              pos = quot;
            }
          } else if (state === STATE_IGNORE_COMMENT) {
            // if we're looping through a comment, fast-forward using
            // indexOf to the first end-comment character
            var endcomment = data.indexOf('-->', pos);

            if (endcomment !== -1) {
              pos = endcomment + 2; // target the '>' character
            }
          }

          var c = data.charCodeAt(pos);

          switch (state) {
            case STATE_TEXT:
              if (c === 60
              /* < */
              ) {
                  var text = endRecording();

                  if (text) {
                    this.emit('text', unescapeXML(text));
                  }

                  state = STATE_TAG_NAME;
                  recordStart = pos + 1;
                  attrs = {};
                }

              break;

            case STATE_CDATA:
              if (c === 93
              /* ] */
              && data.substr(pos + 1, 2) === ']>') {
                var cData = endRecording();

                if (cData) {
                  this.emit('text', cData);
                }

                state = STATE_IGNORE_COMMENT;
              }

              break;

            case STATE_TAG_NAME:
              if (c === 47
              /* / */
              && recordStart === pos) {
                recordStart = pos + 1;
                endTag = true;
              } else if (c === 33
              /* ! */
              ) {
                  if (data.substr(pos + 1, 7) === '[CDATA[') {
                    recordStart = pos + 8;
                    state = STATE_CDATA;
                  } else {
                    recordStart = undefined;
                    state = STATE_IGNORE_COMMENT;
                  }
                } else if (c === 63
              /* ? */
              ) {
                  recordStart = undefined;
                  state = STATE_IGNORE_INSTRUCTION;
                } else if (c <= 32 || c === 47
              /* / */
              || c === 62
              /* > */
              ) {
                  tagName = endRecording();
                  pos--;
                  state = STATE_TAG;
                }

              break;

            case STATE_IGNORE_COMMENT:
              if (c === 62
              /* > */
              ) {
                  var prevFirst = data.charCodeAt(pos - 1);
                  var prevSecond = data.charCodeAt(pos - 2);

                  if (prevFirst === 45
                  /* - */
                  && prevSecond === 45
                  /* - */
                  || prevFirst === 93
                  /* ] */
                  && prevSecond === 93
                  /* ] */
                  ) {
                    state = STATE_TEXT;
                  }
                }

              break;

            case STATE_IGNORE_INSTRUCTION:
              if (c === 62
              /* > */
              ) {
                  var prev = data.charCodeAt(pos - 1);

                  if (prev === 63
                  /* ? */
                  ) {
                      state = STATE_TEXT;
                    }
                }

              break;

            case STATE_TAG:
              if (c === 62
              /* > */
              ) {
                  this._handleTagOpening(endTag, tagName, attrs);

                  tagName = undefined;
                  attrs = undefined;
                  endTag = undefined;
                  selfClosing = undefined;
                  state = STATE_TEXT;
                  recordStart = pos + 1;
                } else if (c === 47
              /* / */
              ) {
                  selfClosing = true;
                } else if (c > 32) {
                recordStart = pos;
                state = STATE_ATTR_NAME;
              }

              break;

            case STATE_ATTR_NAME:
              if (c <= 32 || c === 61
              /* = */
              ) {
                  attrName = endRecording();
                  pos--;
                  state = STATE_ATTR_EQ;
                }

              break;

            case STATE_ATTR_EQ:
              if (c === 61
              /* = */
              ) {
                  state = STATE_ATTR_QUOT;
                }

              break;

            case STATE_ATTR_QUOT:
              if (c === 34
              /* " */
              || c === 39
              /* ' */
              ) {
                  attrQuote = c;
                  attrQuoteChar = c === 34 ? '"' : "'";
                  state = STATE_ATTR_VALUE;
                  recordStart = pos + 1;
                }

              break;

            case STATE_ATTR_VALUE:
              if (c === attrQuote) {
                var value = unescapeXML(endRecording());
                attrs[attrName] = value;
                attrName = undefined;
                state = STATE_TAG;
              }

              break;
          }
        }

        if (typeof recordStart === 'number' && recordStart <= data.length) {
          remainder = data.slice(recordStart);
          recordStart = 0;
        }
      };
    };

    inherits$2(SaxLtx, EventEmitter$1);

    SaxLtx.prototype.end = function (data) {
      if (data) {
        this.write(data);
      }
      /* Uh, yeah */


      this.write = function () {};
    };
  });

  class XMLError extends Error {
    constructor(...args) {
      super(...args);
      this.name = 'XMLError';
    }

  }

  class Parser extends EventEmitter {
    constructor() {
      super();
      const parser = new ltx();
      this.root = null;
      this.cursor = null;
      parser.on('startElement', this.onStartElement.bind(this));
      parser.on('endElement', this.onEndElement.bind(this));
      parser.on('text', this.onText.bind(this));
      this.parser = parser;
    }

    onStartElement(name, attrs) {
      const element = new Element_1$1(name, attrs);
      const {
        root,
        cursor
      } = this;

      if (!root) {
        this.root = element;
        this.emit('start', element);
      } else if (cursor !== root) {
        cursor.append(element);
      }

      this.cursor = element;
    }

    onEndElement(name) {
      const {
        root,
        cursor
      } = this;

      if (name !== cursor.name) {
        // <foo></bar>
        this.emit('error', new XMLError(`${cursor.name} must be closed.`));
        return;
      }

      if (cursor === root) {
        this.emit('end', root);
        return;
      }

      if (!cursor.parent) {
        if (cursor.name.startsWith('stream:')) {
          cursor.attrs['xmlns:stream'] = root.attrs['xmlns:stream'];
        }

        this.emit('element', cursor);
        this.cursor = root;
        return;
      }

      this.cursor = cursor.parent;
    }

    onText(str) {
      const {
        cursor
      } = this;

      if (!cursor) {
        this.emit('error', new XMLError(`${str} must be a child.`));
        return;
      }

      cursor.t(str);
    }

    write(data) {
      this.parser.write(data);
    }

    end(data) {
      if (data) {
        this.parser.write(data);
      }
    }

  }

  Parser.XMLError = XMLError;
  var Parser_1 = Parser;

  var xml_1 = createCommonjsModule(function (module, exports) {

    const {
      escapeXML,
      unescapeXML,
      escapeXMLText,
      unescapeXMLText
    } = _escape;

    function xml(...args) {
      return x_1(...args);
    } // eslint-disable-next-line no-global-assign


    exports = module.exports = xml;
    Object.assign(exports, {
      x: x_1,
      Element: Element_1$1,
      Parser: Parser_1,
      escapeXML,
      unescapeXML,
      escapeXMLText,
      unescapeXMLText
    });
  });

  var detect = function (local) {
    if (!local) {
      return false;
    } // Remove all escaped sequences


    const tmp = local.replace(/\\20/g, '').replace(/\\22/g, '').replace(/\\26/g, '').replace(/\\27/g, '').replace(/\\2f/g, '').replace(/\\3a/g, '').replace(/\\3c/g, '').replace(/\\3e/g, '').replace(/\\40/g, '').replace(/\\5c/g, ''); // Detect if we have unescaped sequences

    const search = tmp.search(/\\| |"|&|'|\/|:|<|>|@/g);

    if (search === -1) {
      return false;
    }

    return true;
  };
  /**
   * Escape the local part of a JID.
   *
   * @see http://xmpp.org/extensions/xep-0106.html
   * @param String local local part of a jid
   * @return An escaped local part
   */


  var escape = function (local) {
    if (local === null) {
      return null;
    }

    return local.replace(/^\s+|\s+$/g, '').replace(/\\/g, '\\5c').replace(/ /g, '\\20').replace(/"/g, '\\22').replace(/&/g, '\\26').replace(/'/g, '\\27').replace(/\//g, '\\2f').replace(/:/g, '\\3a').replace(/</g, '\\3c').replace(/>/g, '\\3e').replace(/@/g, '\\40').replace(/\3a/g, '\u0005c3a');
  };
  /**
   * Unescape a local part of a JID.
   *
   * @see http://xmpp.org/extensions/xep-0106.html
   * @param String local local part of a jid
   * @return unescaped local part
   */


  var unescape = function (local) {
    if (local === null) {
      return null;
    }

    return local.replace(/\\20/g, ' ').replace(/\\22/g, '"').replace(/\\26/g, '&').replace(/\\27/g, "'").replace(/\\2f/g, '/').replace(/\\3a/g, ':').replace(/\\3c/g, '<').replace(/\\3e/g, '>').replace(/\\40/g, '@').replace(/\\5c/g, '\\');
  };

  var escaping = {
    detect: detect,
    escape: escape,
    unescape: unescape
  };

  /**
   * JID implements
   * - XMPP addresses according to RFC6122
   * - XEP-0106: JID Escaping
   *
   * @see http://tools.ietf.org/html/rfc6122#section-2
   * @see http://xmpp.org/extensions/xep-0106.html
   */


  class JID {
    constructor(local, domain, resource) {
      if (typeof domain !== 'string' || !domain) {
        throw new TypeError(`Invalid domain.`);
      }

      this.setDomain(domain);
      this.setLocal(typeof local === 'string' ? local : '');
      this.setResource(typeof resource === 'string' ? resource : '');
    }

    [Symbol.toPrimitive](hint) {
      if (hint === 'number') {
        return NaN;
      }

      return this.toString();
    }

    toString(unescape) {
      let s = this._domain;

      if (this._local) {
        s = this.getLocal(unescape) + '@' + s;
      }

      if (this._resource) {
        s = s + '/' + this._resource;
      }

      return s;
    }
    /**
     * Convenience method to distinguish users
     * */


    bare() {
      if (this._resource) {
        return new JID(this._local, this._domain, null);
      }

      return this;
    }
    /**
     * Comparison function
     * */


    equals(other) {
      return this._local === other._local && this._domain === other._domain && this._resource === other._resource;
    }
    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-localpart
     * */


    setLocal(local, escape) {
      escape = escape || escaping.detect(local);

      if (escape) {
        local = escaping.escape(local);
      }

      this._local = local && local.toLowerCase();
      return this;
    }

    getLocal(unescape) {
      unescape = unescape || false;
      let local = null;

      if (unescape) {
        local = escaping.unescape(this._local);
      } else {
        local = this._local;
      }

      return local;
    }
    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-domain
     */


    setDomain(domain) {
      this._domain = domain.toLowerCase();
      return this;
    }

    getDomain() {
      return this._domain;
    }
    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-resourcepart
     */


    setResource(resource) {
      this._resource = resource;
      return this;
    }

    getResource() {
      return this._resource;
    }

  }

  Object.defineProperty(JID.prototype, 'local', {
    get: JID.prototype.getLocal,
    set: JID.prototype.setLocal
  });
  Object.defineProperty(JID.prototype, 'domain', {
    get: JID.prototype.getDomain,
    set: JID.prototype.setDomain
  });
  Object.defineProperty(JID.prototype, 'resource', {
    get: JID.prototype.getResource,
    set: JID.prototype.setResource
  });
  var JID_1 = JID;

  var parse = function parse(s) {
    let local;
    let resource;
    const resourceStart = s.indexOf('/');

    if (resourceStart !== -1) {
      resource = s.substr(resourceStart + 1);
      s = s.substr(0, resourceStart);
    }

    const atStart = s.indexOf('@');

    if (atStart !== -1) {
      local = s.substr(0, atStart);
      s = s.substr(atStart + 1);
    }

    return new JID_1(local, s, resource);
  };

  var jid_1 = createCommonjsModule(function (module, exports) {

    function jid(...args) {
      if (!args[1] && !args[2]) {
        return parse(...args);
      }

      return new JID_1(...args);
    } // eslint-disable-next-line no-global-assign


    exports = module.exports = jid.bind();
    exports.jid = jid;
    exports.JID = JID_1;

    exports.equal = function (a, b) {
      return a.equals(b);
    };

    exports.detectEscape = escaping.detect;
    exports.escapeLocal = escaping.escape;
    exports.unescapeLocal = escaping.unescape;
    exports.parse = parse;
  });
  var jid_2 = jid_1.jid;
  var jid_3 = jid_1.JID;
  var jid_4 = jid_1.equal;
  var jid_5 = jid_1.detectEscape;
  var jid_6 = jid_1.escapeLocal;
  var jid_7 = jid_1.unescapeLocal;
  var jid_8 = jid_1.parse;

  const {
    EventEmitter: EventEmitter$1
  } = events;
  const NS = 'jabber:iq:roster';

  function parseItem(item) {
    return Object.assign({}, item.attrs, {
      groups: item.getChildren('group').map(group => group.text()),
      approved: item.attrs.approved === 'true',
      ask: item.attrs.ask === 'subscribe',
      name: item.attrs.name || '',
      subscription: item.attrs.subscription || 'none',
      jid: new jid_1(item.attrs.jid)
    });
  }

  class RosterPlugin extends EventEmitter$1 {
    constructor(client) {
      super();
      this.client = client;
      this.start();
    }
    /** @typedef {{items: object, version?: string }} Roster */

    /**
     * Retrieve the roster.
     *
     * @param {string|undefined} version Roster version
     * @returns {Promise<Roster|null>} List of roster items. If a version
     *    was specified and is still the latest version `null` is returned.
     */


    get(version) {
      const {
        iqCaller
      } = this.client;
      return iqCaller.request(xml_1('iq', {
        type: 'get'
      }, xml_1('query', {
        xmlns: NS,
        ver: version
      }))).then(res => {
        // An empty iq response means no new version is available
        if (res.children.length === 0) {
          return null;
        }

        const result = res.getChild('query');
        return {
          items: result.getChildren('item').map(x => parseItem(x)),
          version: result.attrs.ver
        };
      });
    }
    /**
     * Update the roster
     *
     * @param {string|JID.JID|object} item Roster to set
     * @returns {Promise<undefined>} Completion promise
     */


    set(item) {
      const {
        iqCaller
      } = this.client;

      if (typeof item === 'string' || item instanceof jid_1.JID) {
        item = {
          jid: item
        };
      }

      const groups = item.groups || [];
      delete item.groups;
      return iqCaller.request(xml_1('iq', {
        type: 'set'
      }, xml_1('query', {
        xmlns: NS
      }, xml_1('item', item, groups.map(g => xml_1('group', {}, g)))))).then(() => undefined);
    }
    /**
     * Remote an item from the roster.
     *
     * @param {string} jid Jabber id for item to remove from the roster
     * @returns {Promise<void>} Completion promise
     */


    remove(jid) {
      const {
        iqCaller
      } = this.client;
      return iqCaller.request(xml_1('iq', {
        type: 'set'
      }, xml_1('query', {
        xmlns: NS
      }, xml_1('item', {
        jid,
        subscription: 'remove'
      })))).then(() => undefined);
    } // Handles roster pushes


    start() {
      const {
        iqCallee
      } = this.client;
      iqCallee.set(NS, 'query', context => {
        const child = context.element;
        const item = parseItem(child.getChild('item'));

        if (item.subscription === 'remove') {
          this.emit('remove', {
            jid: item.jid,
            version: child.attrs.ver
          });
        } else {
          this.emit('set', {
            item,
            version: child.attrs.ver
          });
        }

        return true;
      });
    }

  }
  /**
   * Register a roster plugin.
   *
   * @param {Client} client XMPP client instance
   * @returns {RosterPlugin} Plugin instance
   */


  function setupRoster(client) {
    return new RosterPlugin(client);
  }

  var src = setupRoster;

  return src;

}));
